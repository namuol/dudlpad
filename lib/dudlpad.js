// Generated by CoffeeScript 1.3.1
(function() {
  var DUDLPAD, canHaveCallback, history, noFalses, __clearCallbacks,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  DUDLPAD = {};

  if (typeof module !== "undefined" && module !== null) {
    module.exports = DUDLPAD;
  } else {
    window.DUDLPAD = DUDLPAD;
  }

  noFalses = function(array) {
    var val;
    if (array.length > 0) {
      val = array.pop();
      if (val === false) {
        return false;
      }
      return noFalses(array);
    }
    return true;
  };

  __clearCallbacks = {};

  canHaveCallback = function(pad, inner, retVal) {
    var after, before, clearCallbacks, func;
    before = [];
    after = [];
    before.remove = after.remove = function(from, to) {
      var rest;
      rest = this.slice((to || from) + 1 || this.length);
      this.length = from < 0 ? this.length + from : from;
      return this.push.apply(this, rest);
    };
    clearCallbacks = function() {
      before = [];
      return after = [];
    };
    return func = function() {
      var aft, args, bef, beforeResults, res, _i, _j, _len, _len1;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args[0] != null) {
        if (typeof args[0] === 'function') {
          before.push(args[0]);
          return retVal;
        } else if (args[0] === __clearCallbacks) {
          clearCallbacks();
          return retVal;
        } else if (typeof args[0] === 'object' && ((args[0].before != null) || (args[0].after != null))) {
          if (args[0].before != null) {
            before.push(args[0].before);
          }
          if (args[0].after != null) {
            after.push(args[0].after);
          }
          return retVal;
        }
      }
      beforeResults = [];
      for (_i = 0, _len = before.length; _i < _len; _i++) {
        bef = before[_i];
        beforeResults.push(bef.apply(pad, args));
      }
      if (noFalses(beforeResults)) {
        res = inner.apply(pad, args);
      }
      for (_j = 0, _len1 = after.length; _j < _len1; _j++) {
        aft = after[_j];
        aft.apply(pad, args);
      }
      return res;
    };
  };

  history = function() {
    var beforeUndo, hist, hpos, punchIn, punchOut, punchedIn, redo, undo, wrap, _beforeUndo;
    wrap = function(func) {
      return function() {
        var args, res;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        res = func.apply(func, args);
        if (punchedIn) {
          hist[hpos].push({
            func: func,
            args: args
          });
        }
        return res;
      };
    };
    hist = [];
    hpos = -1;
    punchedIn = false;
    punchIn = function() {
      punchedIn = true;
      hpos += 1;
      hist[hpos] = [];
      return hist[hpos + 1] = null;
    };
    punchOut = function(callback) {
      return punchedIn = false;
    };
    _beforeUndo = null;
    beforeUndo = function(func) {
      return _beforeUndo = func;
    };
    undo = function() {
      var i, j;
      if (punchedIn) {
        throw 'attempted to call `undo` during an operation that alters history';
      } else if (hpos < 0) {
        return;
      }
      if (_beforeUndo != null) {
        _beforeUndo();
      }
      i = 0;
      while (i < hpos && (hist[i] != null)) {
        j = 0;
        while (j < hist[i].length) {
          hist[i][j].func.apply(hist[i][j].func, hist[i][j].args);
          j += 1;
        }
        i += 1;
      }
      return hpos -= 1;
    };
    redo = function() {
      var current, i, next;
      next = hist[hpos + 1];
      if (next != null) {
        i = 0;
        while (i < next.length) {
          current = next[i];
          current.func.apply(current.func, current.args);
          i += 1;
        }
        return hpos += 1;
      }
    };
    return {
      wrap: wrap,
      punchIn: punchIn,
      punchOut: punchOut,
      beforeUndo: beforeUndo,
      undo: undo,
      redo: redo
    };
  };

  DUDLPAD.create = function(canvas) {
    var clearCanvas, context, drawLines, drawing, hist, lineWidth, pad, resetAll, resetCanvas, strokeStyle;
    if (!(canvas != null)) {
      throw 'null canvas was passed to `create`.';
    }
    drawLines = null;
    hist = null;
    strokeStyle = null;
    lineWidth = null;
    clearCanvas = null;
    resetCanvas = function() {
      clearCanvas();
      context.strokeStyle = 'black';
      context.lineWidth = 2.0;
      context.lineCap = 'round';
      return context.lineJoin = 'round';
    };
    resetAll = function() {
      hist = history();
      hist.beforeUndo(resetCanvas);
      clearCanvas = hist.wrap(function() {
        return context.clearRect(0, 0, canvas.width, canvas.height);
      });
      drawLines = hist.wrap(function(style, coords) {
        var i, name, value;
        for (name in style) {
          if (!__hasProp.call(style, name)) continue;
          value = style[name];
          context[name] = value;
        }
        context.beginPath();
        i = 0;
        while (i + 3 < coords.length) {
          context.moveTo(coords[i], coords[i + 1]);
          context.lineTo(coords[i + 2], coords[i + 3]);
          i += 2;
        }
        context.closePath();
        return context.stroke();
      });
      resetCanvas();
      strokeStyle = context.strokeStyle;
      return lineWidth = context.lineWidth;
    };
    context = canvas.getContext('2d');
    resetAll();
    drawing = false;
    return pad = {
      start: canHaveCallback(this, function(pos, color) {
        var _strokeStyle;
        drawing = true;
        hist.punchIn();
        if (color != null) {
          _strokeStyle = color;
        } else {
          _strokeStyle = strokeStyle;
        }
        drawLines({
          lineWidth: lineWidth,
          strokeStyle: _strokeStyle
        }, [pos[0], pos[1], pos[0], pos[1] + 0.1]);
        return this;
      }),
      draw: canHaveCallback(this, function(coords, color) {
        var _strokeStyle;
        if (color != null) {
          _strokeStyle = color;
        } else {
          _strokeStyle = strokeStyle;
        }
        drawLines({
          lineWidth: lineWidth,
          strokeStyle: _strokeStyle
        }, coords);
        return this;
      }),
      end: canHaveCallback(this, function(pos) {
        drawing = false;
        hist.punchOut();
        return this;
      }),
      undo: canHaveCallback(this, function() {
        hist.undo();
        return this;
      }),
      redo: canHaveCallback(this, function() {
        hist.redo();
        return this;
      }),
      lineColor: canHaveCallback(this, function(color) {
        if (arguments.length === 0) {
          return strokeStyle;
        }
        strokeStyle = color;
        return this;
      }),
      lineWidth: canHaveCallback(this, function(width) {
        if (arguments.length === 0) {
          return lineWidth;
        }
        lineWidth = width;
        return this;
      }),
      clear: canHaveCallback(this, function() {
        hist.punchIn();
        clearCanvas();
        hist.punchOut();
        return this;
      }),
      reset: canHaveCallback(this, function() {
        resetAll();
        return this;
      }),
      unbind: function(name) {
        if (this[name] != null) {
          return this[name](__clearCallbacks);
        }
      }
    };
  };

}).call(this);
